## **버블 정렬**

- 버블 정렬은 **두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬**하는 방법이다.
- 마치 거품이(비교 및 교환이) 터지면서 위로 올라오는(배열의 옆으로 이동하는) 방식이다.
- 버블 정렬은 **단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중**한다.
- 이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.
**중첩 루프를 돌아야** 하고, n개의 값이 주어졌을 때 각 루프는 각각 n-1번, n-2번 반복 되므로
(n-1)*(n-2) = n^2-3n+2 번의 비교 및 교환이 필요한데, 여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 **버블 정렬 실행 시간의 상한은 O(n^2)** 이라고 말할 수 있다.
- 정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로, 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 된다.
- 그러나 만약 이미 정렬이 모두 되어 있다면 교환이 일어나지 않아도 된다. 그래서 **최종적으로 버블 정렬의 하한은 Ω(n)** 이 된다.

## **선택 정렬**

- 선택정렬은 **배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식**이다.
- 선택 정렬은 **교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가**한다.
- 선택 정렬도 **두 번의 루프**를 돌아야 한다. 바깥 루프에서는 숫자들을 처음부터 순서대로 방문하고, 안쪽 루프에서는 가장 작은 값을 찾아야 한다.따라서 **소요 시간의 상한은 O(n^2)** 이고, **하한도 마찬가지로 Ω(n^2)** 이다. **버블 정렬과 동일**하다.

## **병합 정렬**

- 병합 정렬은 **원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식**이다.
- 전화번호부의 분할 정복 탐색처럼 **데이터를 반으로 나누어간다**는 것과 공통점이 있다.
- **3단계**로 이루어진다. <br/> -> **1) 왼쪽 절반 정렬, 2) 오른쪽 절반 정렬, 3) 1,2를 정렬시키며 병합**
- **병합 정렬 실행 시간의 상한은 O(n log n)** 이다. 숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문이다.
- **실행 시간의 하한도 역시 Ω(n log n)** 이다. 숫자들이 이미 정렬 되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문이다.

※ 참고 : 어떤 **알고리즘의 상한선과 하한선이 같을 때는 Theta 표기법**을 사용한다. (선택정렬, 병합정렬)
